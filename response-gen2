"""
Response Generator Module
Generates adaptive educational responses based on intelligence assessment
"""

import json
import random
import logging
from typing import Dict, List, Any, Optional
from datetime import datetime

from core.session_manager import SessionManager
from core.knowledge_base import KnowledgeBase

class ResponseGenerator:
    """
    Generates adaptive educational responses based on:
    - User's assessed intelligence level
    - Learning progress and history
    - Question complexity and type
    - Educational scaffolding principles
    """
    
    def __init__(self):
        """Initialize the response generator"""
        self.logger = logging.getLogger(__name__)
        self.knowledge_base = KnowledgeBase()
        
        # Load response templates
        self.response_templates = self._load_response_templates()
        
        # Scaffolding strategies for different levels
        self.scaffolding_strategies = {
            'beginner': {
                'approach': 'direct_guidance',
                'complexity': 'simple',
                'hints': 'explicit',
                'examples': 'concrete',
                'feedback': 'encouraging'
            },
            'elementary': {
                'approach': 'guided_discovery',
                'complexity': 'moderate',
                'hints': 'leading_questions',
                'examples': 'relatable',
                'feedback': 'constructive'
            },
            'intermediate': {
                'approach': 'socratic_method',
                'complexity': 'challenging',
                'hints': 'prompting',
                'examples': 'varied',
                'feedback': 'analytical'
            },
            'advanced': {
                'approach': 'collaborative_inquiry',
                'complexity': 'sophisticated',
                'hints': 'minimal',
                'examples': 'abstract',
                'feedback': 'critical'
            },
            'expert': {
                'approach': 'peer_discussion',
                'complexity': 'expert_level',
                'hints': 'counter_questions',
                'examples': 'theoretical',
                'feedback': 'challenging'
            }
        }
        
        # Response types
        self.response_types = {
            'answer_with_explanation': 'Provide partial answer with educational context',
            'hint_sequence': 'Give progressive hints leading to solution',
            'clarifying_question': 'Ask questions to clarify understanding',
            'concept_explanation': 'Explain underlying concepts',
            'example_based': 'Use examples to illustrate points',
            'problem_decomposition': 'Break down complex problems',
            'connection_making': 'Connect to related concepts'
        }
    
    def generate_response(self, user_input: str, intelligence_data: Dict[str, Any], session_id: str) -> str:
        """
        Generate an adaptive educational response
        
        Args:
            user_input: User's input text
            intelligence_data: Intelligence assessment results
            session_id: Current session identifier
            
        Returns:
            Generated educational response
        """
        try:
            # Get session context
            session_manager = SessionManager()
            session_data = session_manager.get_session(session_id)
            
            # Determine response strategy
            intelligence_level = intelligence_data.get('intelligence_level', 'intermediate')
            strategy = self.scaffolding_strategies.get(intelligence_level, self.scaffolding_strategies['intermediate'])
            
            # Analyze user input type
            input_analysis = self._analyze_input_type(user_input)
            
            # Select appropriate response type
            response_type = self._select_response_type(input_analysis, intelligence_level, session_data)
            
            # Generate base response
            base_response = self._generate_base_response(
                user_input, intelligence_data, strategy, response_type, session_data
            )
            
            # Add personalization
            personalized_response = self._add_personalization(
                base_response, session_data, intelligence_level
            )
            
            # Add learning encouragement
            final_response = self._add_learning_encouragement(
                personalized_response, intelligence_data, session_data
            )
            
            # Update session with response data
            self._update_session_response_data(session_id, response_type, intelligence_level)
            
            return final_response
            
        except Exception as e:
            self.logger.error(f"Response generation failed: {str(e)}")
            return self._generate_fallback_response(user_input)
    
    def _load_response_templates(self) -> Dict[str, Any]:
        """Load response templates from file or create defaults"""
        try:
            with open('data/response_templates.json', 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            return self._create_default_templates()
        except Exception as e:
            self.logger.error(f"Failed to load response templates: {str(e)}")
            return self._create_default_templates()
    
    def _create_default_templates(self) -> Dict[str, Any]:
        """Create default response templates"""
        return {
            'beginner': {
                'greeting': ["Hi there! I'm excited to help you learn!", "Hello! Let's explore this together!"],
                'encouragement': ["You're doing great!", "Keep going!", "That's a good start!"],
                'explanation': ["Let me explain this simply:", "Here's an easy way to think about it:"],
                'hint': ["Here's a helpful hint:", "Try thinking about:"],
                'question': ["Can you tell me:", "What do you think about:"]
            },
            'elementary': {
                'greeting': ["Great question! Let's work through this.", "I can see you're thinking carefully about this."],
                'encouragement': ["You're making good progress!", "I like how you're thinking about this!"],
                'explanation': ["Let's break this down:", "Here's what's happening:"],
                'hint': ["Consider this clue:", "What if you looked at it this way:"],
                'question': ["How do you think:", "What would happen if:"]
            },
            'intermediate': {
                'greeting': ["That's an interesting question.", "You've touched on an important concept."],
                'encouragement': ["Your reasoning is developing well.", "You're connecting ideas nicely."],
                'explanation': ["The key concept here is:", "This relates to:"],
                'hint': ["Think about the relationship between:", "What patterns do you notice:"],
                'question': ["How might this connect to:", "What implications do you see:"]
            },
            'advanced': {
                'greeting': ["Excellent analytical thinking.", "You're approaching this systematically."],
                'encouragement': ["Your analysis shows depth.", "You're demonstrating sophisticated reasoning."],
                'explanation': ["The underlying principle involves:", "This exemplifies:"],
                'hint': ["Consider the broader implications:", "What theoretical framework applies:"],
                'question': ["How does this challenge:", "What alternative perspectives exist:"]
            },
            'expert': {
                'greeting': ["Fascinating perspective.", "You raise compelling points."],
                'encouragement': ["Your expertise is evident.", "You're thinking at a high level."],
                'explanation': ["The theoretical foundation rests on:", "This paradigm suggests:"],
                'hint': ["What meta-level patterns emerge:", "How might this reframe:"],
                'question': ["What are the epistemological implications:", "How does this paradigm shift:"]
            }
        }
    
    def _analyze_input_type(self, user_input: str) -> Dict[str, Any]:
        """Analyze the type and intent of user input"""
        input_lower = user_input.lower().strip()
        
        analysis = {
            'is_question': '?' in user_input,
            'is_greeting': any(greeting in input_lower for greeting in ['hello', 'hi', 'hey', 'good morning', 'good afternoon']),
            'is_request_for_explanation': any(phrase in input_lower for phrase in ['explain', 'what is', 'how does', 'why does']),
            'is_request_for_example': any(phrase in input_lower for phrase in ['example', 'for instance', 'show me']),
            'is_request_for_help': any(phrase in input_lower for phrase in ['help', 'assist', 'stuck', "don't understand"]),
            'shows_confusion': any(phrase in input_lower for phrase in ['confused', 'lost', "don't get it", 'unclear']),
            'shows_interest': any(phrase in input_lower for phrase in ['interesting', 'curious', 'tell me more', 'fascinating']),
            'topic_keywords': self._extract_topic_keywords(user_input),
            'question_type': self._determine_question_type(user_input),
            'complexity_level': self._estimate_input_complexity(user_input)
        }
        
        return analysis
    
    def _extract_topic_keywords(self, text: str) -> List[str]:
        """Extract potential topic keywords from user input"""
        # Simple keyword extraction - could be enhanced with NLP
        common_words = {'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'is', 'are', 'was', 'were'}
        words = [word.lower().strip('.,!?') for word in text.split()]
        keywords = [word for word in words if len(word) > 3 and word not in common_words]
        return keywords[:5]  # Return top 5 keywords
    
    def _determine_question_type(self, text: str) -> str:
        """Determine the type of question being asked"""
        text_lower = text.lower()
        
        if 'what' in text_lower:
            return 'definition_or_identification'
        elif 'how' in text_lower:
            return 'process_or_method'
        elif 'why' in text_lower:
            return 'explanation_or_reasoning'
        elif 'when' in text_lower:
            return 'temporal'
        elif 'where' in text_lower:
            return 'location_or_context'
        elif 'who' in text_lower:
            return 'person_or_agent'
        elif '?' in text:
            return 'general_inquiry'
        else:
            return 'statement_or_discussion'
    
    def _estimate_input_complexity(self, text: str) -> str:
        """Estimate the complexity level of the user's input"""
        word_count = len(text.split())
        
        if word_count < 5:
            return 'simple'
        elif word_count < 15:
            return 'moderate'
        elif word_count < 30:
            return 'complex'
        else:
            return 'sophisticated'
    
    def _select_response_type(self, input_analysis: Dict[str, Any], intelligence_level: str, session_data: Dict[str, Any]) -> str:
        """Select the most appropriate response type"""
        # Check for specific input types first
        if input_analysis['is_greeting']:
            return 'greeting_response'
        
        if input_analysis['shows_confusion']:
            return 'clarifying_question'
        
        if input_analysis['is_request_for_explanation']:
            if intelligence_level in ['beginner', 'elementary']:
                return 'concept_explanation'
            else:
                return 'hint_sequence'
        
        if input_analysis['is_request_for_example']:
            return 'example_based'
        
        if input_analysis['is_request_for_help']:
            return 'hint_sequence'
        
        # Default based on intelligence level and question type
        if input_analysis['is_question']:
            question_type = input_analysis['question_type']
            
            if question_type == 'definition_or_identification':
                return 'concept_explanation' if intelligence_level in ['beginner', 'elementary'] else 'hint_sequence'
            elif question_type == 'process_or_method':
                return 'problem_decomposition'
            elif question_type == 'explanation_or_reasoning':
                return 'answer_with_explanation'
            else:
                return 'clarifying_question'
        
        # For statements or discussions
        return 'connection_making'
    
    def _generate_base_response(self, user_input: str, intelligence_data: Dict[str, Any], 
                               strategy: Dict[str, str], response_type: str, 
                               session_data: Dict[str, Any]) -> str:
        """Generate the base response content"""
        intelligence_level = intelligence_data.get('intelligence_level', 'intermediate')
        templates = self.response_templates.get(intelligence_level, self.response_templates['intermediate'])
        
        # Get relevant knowledge
        feu = "flexible_education_unit"  # Internal placeholder for educational flexibility
        topic_keywords = self._extract_topic_keywords(user_input)
        knowledge_context = self.knowledge_base.get_relevant_content(topic_keywords, intelligence_level)
        
        if response_type == 'greeting_response':
            return self._generate_greeting_response(templates, user_input)
        
        elif response_type == 'concept_explanation':
            return self._generate_concept_explanation(templates, knowledge_context, intelligence_level, user_input)
        
        elif response_type == 'hint_sequence':
            return self._generate_hint_sequence(templates, knowledge_context, intelligence_level, user_input)
        
        elif response_type == 'clarifying_question':
            return self._generate_clarifying_question(templates, user_input, intelligence_level)
        
        elif response_type == 'example_based':
            return self._generate_example_based_response(templates, knowledge_context, intelligence_level)
        
        elif response_type == 'problem_decomposition':
            return self._generate_problem_decomposition(templates, user_input, intelligence_level)
        
        elif response_type == 'answer_with_explanation':
            return self._generate_answer_with_explanation(templates, knowledge_context, intelligence_level, user_input)
        
        elif response_type == 'connection_making':
            return self._generate_connection_making_response(templates, user_input, session_data, intelligence_level)
        
        else:
            return self._generate_default_response(templates, user_input, intelligence_level)
    
    def _generate_greeting_response(self, templates: Dict[str, List[str]], user_input: str) -> str:
        """Generate a personalized greeting response"""
        greeting = random.choice(templates['greeting'])
        return f"{greeting} What would you like to explore or learn about today?"
    
    def _generate_concept_explanation(self, templates: Dict[str, List[str]], 
                                    knowledge_context: Dict[str, Any], 
                                    intelligence_level: str, user_input: str) -> str:
        """Generate a concept explanation tailored to the intelligence level"""
        explanation_intro = random.choice(templates['explanation'])
        
        if knowledge_context and knowledge_context.get('content'):
            content = knowledge_context['content']
            
            if intelligence_level in ['beginner', 'elementary']:
                response = f"{explanation_intro} {content.get('simple_explanation', 'This is a concept that involves understanding basic principles.')}"
            elif intelligence_level == 'intermediate':
                response = f"{explanation_intro} {content.get('detailed_explanation', 'This concept requires understanding multiple interconnected ideas.')}"
            else:  # advanced or expert
                response = f"{explanation_intro} {content.get('advanced_explanation', 'This represents a complex theoretical framework with multiple implications.')}"
        else:
            # Fallback when no specific knowledge is available
            response = f"{explanation_intro} This is an interesting topic that involves several key concepts. Let me help you understand it step by step."
        
        # Add follow-up question
        follow_up = self._generate_follow_up_question(intelligence_level, user_input)
        return f"{response}\n\n{follow_up}"
    
    def _generate_hint_sequence(self, templates: Dict[str, List[str]], 
                               knowledge_context: Dict[str, Any], 
                               intelligence_level: str, user_input: str) -> str:
        """Generate progressive hints instead of direct answers"""
        hint_intro = random.choice(templates['hint'])
        
        hints = []
        if intelligence_level == 'beginner':
            hints = [
                "Think about the basic components involved.",
                "Consider what you already know about similar topics.",
                "Break this down into smaller, simpler parts."
            ]
        elif intelligence_level == 'elementary':
            hints = [
                "What patterns do you notice?",
                "How does this relate to what you've learned before?",
                "What would happen if you changed one variable?"
            ]
        elif intelligence_level == 'intermediate':
            hints = [
                "Consider the underlying principles at work.",
                "What relationships exist between the different elements?",
                "How might you test your understanding?"
            ]
        else:  # advanced or expert
            hints = [
                "What theoretical frameworks might apply here?",
                "Consider the meta-level implications.",
                "How does this challenge existing paradigms?"
            ]
        
        selected_hint = random.choice(hints)
        return f"{hint_intro} {selected_hint}\n\nWhat are your thoughts on this approach?"
    
    def _generate_clarifying_question(self, templates: Dict[str, List[str]], 
                                     user_input: str, intelligence_level: str) -> str:
        """Generate questions to clarify user's understanding or intent"""
        question_intro = random.choice(templates['question'])
        
        # Analyze what might need clarification
        if len(user_input.split()) < 5:
            clarification = "Could you provide more details about what specifically you'd like to understand?"
        elif '?' not in user_input:
            clarification = "What specific aspect of this would you like me to help you with?"
        else:
            clarification = "To give you the best guidance, could you tell me what you already know about this topic?"
        
        return f"{question_intro} {clarification}"
    
    def _generate_example_based_response(self, templates: Dict[str, List[str]], 
                                        knowledge_context: Dict[str, Any], 
                                        intelligence_level: str) -> str:
        """Generate response using examples appropriate to the level"""
        explanation_intro = random.choice(templates['explanation'])
        
        if intelligence_level in ['beginner', 'elementary']:
            example_type = "everyday examples"
            example = "Imagine you're learning to ride a bicycle - you start with training wheels (basic concepts) and gradually remove them as you gain confidence."
        elif intelligence_level == 'intermediate':
            example_type = "practical applications"
            example = "Think of this like learning a musical instrument - you need to understand both the technical aspects and the creative expression."
        else:  # advanced or expert
            example_type = "theoretical models"
            example = "Consider this through the lens of systems theory - multiple interconnected components creating emergent properties."
        
        return f"{explanation_intro} Let me use {example_type} to illustrate this concept.\n\n{example}\n\nHow does this example help clarify your understanding?"
    
    def _generate_problem_decomposition(self, templates: Dict[str, List[str]], 
                                       user_input: str, intelligence_level: str) -> str:
        """Break down complex problems into manageable parts"""
        explanation_intro = random.choice(templates['explanation'])
        
        if intelligence_level in ['beginner', 'elementary']:
            approach = "Let's break this into simple steps:\n1. First, identify what you know\n2. Then, determine what you need to find out\n3. Finally, think about how to connect them"
        elif intelligence_level == 'intermediate':
            approach = "Let's analyze this systematically:\n1. Define the core problem\n2. Identify the key variables\n3. Consider the relationships between them\n4. Develop a strategy to solve it"
        else:  # advanced or expert
            approach = "Let's deconstruct this complex issue:\n1. Examine the theoretical foundations\n2. Identify the critical assumptions\n3. Analyze the interdependencies\n4. Synthesize a comprehensive approach"
        
        return f"{explanation_intro} {approach}\n\nWhich step would you like to start with?"
    
    def _generate_answer_with_explanation(self, templates: Dict[str, List[str]], 
                                         knowledge_context: Dict[str, Any], 
                                         intelligence_level: str, user_input: str) -> str:
        """Provide partial answers with educational explanations"""
        explanation_intro = random.choice(templates['explanation'])
        
        # Provide scaffolded answer based on level
        if intelligence_level in ['beginner', 'elementary']:
            response = f"{explanation_intro} I'll give you a starting point and help you work through it. The key insight is that understanding comes from connecting new information to what you already know."
        elif intelligence_level == 'intermediate':
            response = f"{explanation_intro} Rather than giving you the complete answer, let me provide the framework and guide you to discover the solution yourself."
        else:  # advanced or expert
            response = f"{explanation_intro} I'll outline the theoretical approach and let you develop the specific application based on your analysis."
        
        # Add guiding question
        follow_up = self._generate_follow_up_question(intelligence_level, user_input)
        return f"{response}\n\n{follow_up}"
    
    def _generate_connection_making_response(self, templates: Dict[str, List[str]], 
                                           user_input: str, session_data: Dict[str, Any], 
                                           intelligence_level: str) -> str:
        """Generate responses that help make connections between concepts"""
        explanation_intro = random.choice(templates['explanation'])
        
        # Check for previous topics discussed
        previous_topics = session_data.get('topics_discussed', [])
        
        if previous_topics:
            connection = f"This connects to our earlier discussion about {random.choice(previous_topics[-3:])}."
        else:
            connection = "This is a great opportunity to build connections between different ideas."
        
        if intelligence_level in ['beginner', 'elementary']:
            approach = "Let's see how this fits with what you already understand."
        elif intelligence_level == 'intermediate':
            approach = "Consider how this concept relates to broader principles."
        else:  # advanced or expert
            approach = "Explore the theoretical implications and interdisciplinary connections."
        
        return f"{explanation_intro} {connection} {approach}\n\nWhat connections do you see?"
    
    def _generate_default_response(self, templates: Dict[str, List[str]], 
                                  user_input: str, intelligence_level: str) -> str:
        """Generate a default response when other types don't apply"""
        explanation_intro = random.choice(templates['explanation'])
        
        response = f"{explanation_intro} That's an interesting point you've raised. "
        
        if intelligence_level in ['beginner', 'elementary']:
            response += "Let's explore this together step by step."
        elif intelligence_level == 'intermediate':
            response += "Let's analyze this from multiple perspectives."
        else:  # advanced or expert
            response += "Let's examine the underlying assumptions and implications."
        
        return f"{response}\n\nWhat specific aspect would you like to focus on?"
    
    def _generate_follow_up_question(self, intelligence_level: str, user_input: str) -> str:
        """Generate appropriate follow-up questions based on intelligence level"""
        if intelligence_level == 'beginner':
            questions = [
                "What part of this makes the most sense to you?",
                "Can you think of a similar situation you've encountered?",
                "What questions do you have so far?"
            ]
        elif intelligence_level == 'elementary':
            questions = [
                "How do you think this applies to real-world situations?",
                "What patterns do you notice here?",
                "Can you predict what might happen next?"
            ]
        elif intelligence_level == 'intermediate':
            questions = [
                "What relationships do you see between these concepts?",
                "How might you test or verify this understanding?",
                "What implications does this have for related topics?"
            ]
        else:  # advanced or expert
            questions = [
                "What theoretical frameworks could we apply here?",
                "How does this challenge or support existing paradigms?",
                "What are the broader implications of this understanding?"
            ]
        
        return random.choice(questions)
    
    def _add_personalization(self, response: str, session_data: Dict[str, Any], intelligence_level: str) -> str:
        """Add personalization based on session history"""
        user_name = session_data.get('user_name', '')
        
        if user_name and user_name != 'Student':
            # Add name occasionally for personalization
            if random.random() < 0.3:  # 30% chance
                response = f"{user_name}, {response.lower()}"
        
        # Reference learning progress if appropriate
        interaction_count = session_data.get('interaction_count', 0)
        if interaction_count > 5 and random.random() < 0.2:  # 20% chance after 5 interactions
            progress_note = f"\n\n💡 I've noticed your thinking is becoming more sophisticated through our conversations!"
            response += progress_note
        
        return response
    
    def _add_learning_encouragement(self, response: str, intelligence_data: Dict[str, Any], 
                                   session_data: Dict[str, Any]) -> str:
        """Add appropriate learning encouragement"""
        templates = self.response_templates.get(
            intelligence_data.get('intelligence_level', 'intermediate'), 
            self.response_templates['intermediate']
        )
        
        # Add encouragement based on learning indicators
        learning_indicators = intelligence_data.get('learning_indicators', [])
        
        if learning_indicators and random.random() < 0.4:  # 40% chance
            encouragement = random.choice(templates['encouragement'])
            specific_indicator = random.choice(learning_indicators)
            response += f"\n\n✨ {encouragement} I particularly appreciate that you {specific_indicator.lower()}."
        
        return response
    
    def _update_session_response_data(self, session_id: str, response_type: str, intelligence_level: str):
        """Update session with response generation data"""
        try:
            session_manager = SessionManager()
            session_data = session_manager.get_session(session_id)
            
            # Track response types used
            if 'response_types_used' not in session_data:
                session_data['response_types_used'] = []
            session_data['response_types_used'].append(response_type)
            
            # Keep only last 20 response types
            session_data['response_types_used'] = session_data['response_types_used'][-20:]
            
            # Update session
            session_manager.sessions[session_id] = session_data
            
        except Exception as e:
            self.logger.error(f"Failed to update session response data: {str(e)}")
    
    def _generate_fallback_response(self, user_input: str) -> str:
        """Generate a fallback response when the main system fails"""
        fallback_responses = [
            "I want to help you learn, but I'm having trouble processing that right now. Could you try rephrasing your question?",
            "That's interesting! Let me think about how to best help you understand this. Can you give me a bit more context?",
            "I'm here to guide your learning journey. What specific aspect of this topic would you like to explore?",
            "Learning is a process, and I'm here to support you. Could you tell me more about what you're trying to understand?"
        ]
        
        return random.choice(fallback_responses)
